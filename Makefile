#########################################
### Makefile Cheat Sheet		 		#
#########################################

# Official documentation: https://www.gnu.org/software/make/manual/

#########################################
### The general syntax				    #
#########################################

# The general syntax of Makefiles is as follows:
target_file: list of prerequisite files separated by space
	commands
	to
	build
	target_file
	separeated
	by
	line

# A target is typically the name of a file generated by a program. Examples of targets include executable or object files.
# The target to be executed is specified in the call to make, for example, `make target_file_1 target_file_2`.
# If the target file already exists, Make will check certain conditions to determine whether it needs to recompile the target or not. For further details, please refer to the documentation.
# If no target is specified, Make will execute "the default goal," which is the first target whose name does not start with a dot `.`, unless it also contains one or more forward slashes `/`. This behavior can be overridden, but for further details, please refer to the documentation.
# It is a convention to use `all` as the default goal.

# A prerequisite is a file that is used as an input to create the target. A target often depends on multiple files.

# A target can also be the name of an action to be carried out, such as `clean`, instead of a file name. Such targets are referred to as phony targets.
# As mentioned earlier, if a file with the same name as a phony target exists, it can cause issues. You can explicitly declare targets as phony by using the `.PHONY` directive. 
# For instance, in the example below, we have declared both targets 'phony_target_name' and 'clean' as phony targets.

.PHONY: phony_target_name
phony_target_name:
	@echo "This will be executed even if a file named 'phony_target_name' exists."

.PHONY: clean
clean:
	rm -f ./*.o
	rm -f executable

# Notice how I used multiple `.PHONY` directives here. This is allowed, and it's equivalent to specifying a list of target names separated by spaces within a single `.PHONY` directive. For instance: `.PHONY: phony_target_name clean`.
# In fact, you can do the same for any target. For example, you can have `T: x` in one place and `T: y` in another, and the dependencies for target `T` will be both `x` and `y`.

# Prerequisites files can also be phony. In this case, the phony prerequisite will be called everytime that target is matched.

# `.PHONY` is one of several "Special Built-in Target Names" in Make. Its prerequisites are subject to special rules. For more detailed information, please refer to the documentation.

#########################################
### Standard Phony Targets 				#
#########################################

# There are a few targets that are commonly found inside Makefiles. I will list them below.
# I believe it would be beneficial to include this section as it provides valuable information not only for creating standard Makefiles but also for understanding how to use them effectively.
# They are considered so standard that GNU states that all GNU programs should include not only the following targets but also a few others in their Makefile. Please refer to the documentation for more details on each of these targets.

# - 'all': 
####################

# This target compiles the entire program.

# This should be the default target. 

# This target does not need to rebuild any documentation files. Info files should normally be included in the distribution, and DVI (and other documentation format) files should be generated only when explicitly requested.

# By default, the Make rules should compile and link with '-g' option so that executable programs include debugging symbols. This ensures that you have the necessary information to debug crashes, as it can be challenging to reproduce issues with a fresh build.


# - 'install': 
####################

# This target compiles the program and COPIES the executables, libraries, and other necessary files to their respective locations for actual use. 

# This step may vary significantly in Microsoft Windows compared to a Linux environment. In Linux, there is typically a clear separation between the build step and the installation step. Installation simply refers to the process of copying the built files to their appropriate locations, while the built files are often kept in a separate directory.

# If there is a simple test available to verify that a program is properly installed, this target should execute that test.

# Do not strip executables when installing them. This preserves debugging information that may be needed for future debugging purposes.

# If possible, write the `install` target rule in a way that it does not modify anything in the directory where the program was built, assuming that 'make all' has just been executed. This approach is convenient when building the program under one username and installing it under another.

# The commands should create all the directories in which files are to be installed if they do not already exist.


# - 'uninstall': 
####################

# This target deletes all the installed files, including the copies created by the 'install' and 'install-*' targets.

# This rule should only modify the directories where files are installed and should not affect the directories where compilation is done.


# - 'clean': 
####################

# This target deletes all the files in the current directory that are typically created during the program's build process.

# It should also delete the files in other directories if they are created by this Makefile. However, it should not delete the files that record the configuration.

# It should also preserve files that could be created by building but are typically not generated since they are already included in the distribution. It is not necessary to delete parent directories created with 'mkdir -p' since they could have existed regardless.

# Delete .dvi files here if they are not part of the distribution.


# - 'check': 
####################

# This target performs self-tests, if any are available.

# The user must build the program before running the tests, but it is not necessary to install the program. The self-tests should be written in a way that they can be executed when the program is built but not installed.


# - 'installcheck': 
####################

# Thistarget performs installation tests, if any are available.

# The user must build and install the program before running the tests. It should not be assumed that $(bindir) is in the search path.

#########################################
### Some interesting tips/behaviors 	#
#########################################

# Make will display the command and its result right after it.
# You can suppress the printing of the command by using the `@` symbol right before it. For example:
suppress:
	echo "example_1"
	@echo "example_2"

# AFAIK Makefiles are interpreted. 
# Nevertheless, Make seem to processes all the lines in a Makefile before executing a target.
# This means that a change in a variable at line X+Y (where X, Y > 0) can affect the reading of that variable in a rule defined at line X.

# Parentheses ( ) and curly braces { } are functionally equivalent in Make.

# You can pass flags to sub-make using $(MAKE). For example:
subsystem_build_rule:
	cd subdir && $(MAKE)

#########################################
### Passing arguments			 		#
#########################################

# You can pass arguments to 'make' by exporting them in the shell. For example:
# export foo=3
# And you can simply read them using $(foo).
# In a more standard way, you can also pass them as 'foo=3 make' or 'make foo=3'. To see all the arguments passed using the latter form, you can read the automatic variable $(MAKEFLAGS).
# Arguments passed using the mentioned commands have priority over variables set in the Makefile, which means they will override the Makefile variables. However, you can use the 'override' directive in your Makefile to enforce the value set in the Makefile, like this:
override foo := 42 

#########################################
### Variable assignments		 		#
#########################################

foo1 := Simple_Assignment # Evaluated only once
foo2 = Recursive_Assignment # Evaluated and expanded recursively until they reach a literal value. They are evaluated every time they are called. However, the first evaluation will only occur at the first use of the variable. If a variable is not used, there is no evaluation.
list := like this # Values separated by space
foo3 += String_Concatenation # Concatenates the value of 'foo3' with another value. It works as a list, so a space will be inserted between them. The nature of the assignment (recursive / simple) depends on the definition of 'foo3'.
conditional ?= Maybe # Recursively assigns the variable 'conditional', but only if it is not set.

# If you want a variable to have different values depending on the target it's in, you can use the following syntax:
target_name_1: var_name := a_var_value
target_name_2: var_name := another_var_value

target_name_1:
	echo "$(var_name)"

target_name_2:
	echo "$(var_name)"
 
#########################################
### Pattern rules				 		#
#########################################

# A pattern rule in Make contains the character `%` (exactly one of them) in the target. The target is a pattern that matches file names, where `%` matches any nonempty substring, while other characters match only themselves.

# For example, `%.c` as a pattern matches any file name that ends with `.c`.
# `s.%.c` is a pattern that matches any file name that starts with `s.`, ends with `.c`, and is at least five characters long. It requires at least one character to match the `%` placeholder.
# The substring that the `%` matches is referred to as the "stem."

# Note that expansion using `%` in pattern rules occurs after any variable or function expansions, which take place when the makefile is read.

# In a prerequisite of a pattern rule, `%` stands for the same stem that was matched by the `%` in the target.

# In order for the pattern rule to be applied, the target pattern must match the file name being considered, and all of its prerequisites (after pattern substitution) must specify existing files or files that can be created. These files then become prerequisites of the target.
# Therefore, a rule of the form:
%.a : %.c
	@echo "Also, you can use the variable * to refer to the stem inside the recipe: $*"
# Specifies how to make a file `file1.a` with another file `file1.c` as its prerequisite, provided that `file1.c` exists or can be created.
# Try it yourself: run `make file1.a`, or `make file2.a`, or `make file1.a file2.a file3.a` and observe how things work out.

#########################################
### Some useful Make functions	 		#
#########################################

# $(shell command)
###########

shell_var := $(shell printf "something") # Implicitly executes a shell command and assigns its result to the variable.
# Note that the 'shell' command is a GNU Make built-in, so it may not be available in other versions of Make.
# Also, as mentioned earlier, when using `:=`, the command will only execute once and its value will be stored in the variable. If you use `=`, Make will execute the command every time the variable is used.
# You can observe this behavior in the example below:
shell_once := $(shell printf "once\n" | tee -a output.txt)
shell_rec = $(shell printf "recursive\n" | tee -a output.txt)

target_shell:
	@echo "$(shell_once)"
	@echo "$(shell_once)"
	@echo "$(shell_once)"
	@echo "$(shell_rec)"
	@echo "$(shell_rec)"
	@echo "$(shell_rec)"

# Call this 'make target_shell' and observe the behavior inside output.txt. I recommend erasing the output file first.


# $(wildcard pattern)
###########

list1 := ./*.txt # Notice that the asterisk (*) is treated as a regular character in this context and is not being expanded to nothing.
list2 := $(wildcard *.c) # The wildcard command will automatically expand the list of files that match the specified pattern.

# Note that the wildcard command performs a glob pattern match, not a regular expression match.
# Notice that this kind of expansion happens automatically in rules. However, there are differences in how it behaves. For more details, please refer to the documentation.

# When using the wildcard function, the results are sorted. However, each individual expression is sorted separately. For example, the wildcard below will expand to all files matching .c, sorted, followed by all files matching .h, also sorted.
list3 := $(wildcard *.c *.h)

wild:
	@echo $(list1)
	@echo $(list2)
	@echo $(list3)


# $(patsubst pattern, replacement, text):
###########

# Stands for 'pattern substitution'

# It is used to find whitespace-separated words in text that match a pattern and replace them with a replacement. In the pattern, a `%` acts as a wildcard, matching any number of any characters within a word. If the replacement also contains a `%`, it will be replaced by the text that matched the `%` in the pattern. 

# Words that do not match the pattern remain unchanged in the output. It's important to note that only the first `%` in the pattern and replacement is treated this way; any subsequent `%` are left unchanged.

# As an example, we can convert a list of C source files into a list of object files by replacing the `.c` suffix with `.o`. Here's how:
list3 := $(patsubst %.c, %.o, $(list2))

pattern_sub:
	@echo $(list3)

# Thus, a makefile to compile all C source files in the directory and then link them together could be written as follows:
objects := $(patsubst %.c,%.o,$(wildcard *.c))
executable : $(objects)
	$(CC) -o executable $(objects)

#########################################
### Some useful "Automatic Variables"	#
#########################################

# Check the documentation for more details.
# These are just variable names. You can use $(@) just as fine, for instance.
auto: prereq1 prereq2  
	@echo "@: $@" # The target name (or, in the case of a pattern rule, the file that triggered the target).
	@echo "<: $<" # The name of the first prerequisite
	@echo "?: $?" # The names of all the prerequisites that are newer than the target, separated by spaces. If the target does not exist, all prerequisites will be included.
	@echo "?: $^" # The names of all the prerequisites, with spaces between them.
	@echo "*: $*" # The stem variable (as seen in the 'Pattern Rules' section). When there is no pattern in the rule, the value of this variable may vary. Please refer to the documentation for more details.

prereq1:
	@echo "prereq1"

prereq2:
	@echo "prereq2"

#########################################
### Implicit Rules						#
#########################################

# Certain standard ways of remaking target files are used very often.

# Implicit rules tell make how to use customary techniques so that you don't have to specify them in detail when you want to use them.

# For example, there is an implicit rule for C compilation, and file names determine which implicit rules are executed: 
# For instance, C compilation typically involves a .c file as input and produces a .o file as output. Therefore, when `make` encounters this combination of file name endings, it applies the implicit rule for C compilation.

# Test it yourself: This Makefile does not provide an explicit rule for the target "file1.o", but when you run `make file1.o`, `make` will recognize that you want to generate an object file from `file1.c` based on the file name pattern. It will then execute the following recipe:
# $(CC) $(CPPFLAGS) $(CFLAGS) -c

# The complete list of implicit rules and their recipes is available in the documentation.


#########################################
### Variables Used by Implicit Rules	#
#########################################

# The recipes in built-in implicit rules make extensive use of certain predefined variables.
# These variables are also commonly used when creating your own rules.
# Here is a non-exhaustive list of commonly used variables and their default values. For more details, please refer to the documentation.

imp_vars:
	@echo "CC = $(CC)" # Program for compiling C programs.
	@echo "CXX = $(CXX)" # Program for compiling C++ programs.
	@echo "CPP = $(CPP)" # Program for running the C preprocessor, with results to standard output.
	@echo "RM = $(RM)" # Command to remove a file.
	@echo "ASFLAGS = $(ASFLAGS)" # Extra flags to give to the assembler (when explicitly invoked on a ‘.s’ or ‘.S’ file).
	@echo "CFLAGS = $(CFLAGS)" # Extra flags to give to the C compiler.
	@echo "CXXFLAGS = $(CXXFLAGS)" # Extra flags to give to the C++ compiler.
	@echo "CPPFLAGS = $(CPPFLAGS)" # Extra flags to give to the C preprocessor and programs that use it (the C and Fortran compilers).
	@echo "LDFLAGS = $(LDFLAGS)" # Extra flags to give to compilers when they are supposed to invoke the linker, ‘ld’, such as -L. Libraries (-lfoo) should be added to the LDLIBS variable instead.
	@echo "LDLIBS = $(LDLIBS)" # Library flags or names given to compilers when they are supposed to invoke the linker, ‘ld’. LOADLIBES is a deprecated (but still supported) alternative to LDLIBS. Non-library linker flags, such as -L, should go in the LDFLAGS variable.